# Data Structure Lab Report  

---

<style>
    table
    {
        margin: auto;
    }
</style>

| 实验序号 |    学号    |  姓名  |
| :------: | :--------: | :----: |
|   Lab1   | 2021302488 | 郑安玮 |

---

## 1 问题描述  
1. 给定两个按照升序排列的有序数组，请把它们合成一个升序数组并输出。  
2. 限制使用双向链表作存储结构，请根据用户输入的一个整数（该整数表示精确到小数点后的位数，可能要求精确到小数点后 500 位），高精度计算PI值。可以利用反三角函数幂级展开式来进行计算。  

## 2 问题的数学分析  
### 2.1  
问题要求输入两个升序数组，将两个数组合并后保持单调性，按行输出。  

由于问题涉及频繁插入，并且排序算法不需要随机访问，因此采用单链表作为存储结构。  
> 
> 基本的算法思路如下：  
> + 定义三个链表分别用于存储两个输入矩阵和一个输出矩阵。
> + 依次访问两个输入链表的节点，对节点中的数据域进行比较，将较小值加入输出链表，将较小值指针后移。
> + 重复上述步骤，直到某一链表指针为空。  
> + 将非空指针后续节点加入输出链表。  

### 2.2  
问题要求使用密集展开式计算高精度`π`值，首先看一下反三角函数幂级数展开公式。 
<center> 
<span style="font-size: 24px;">  

$\frac{π}{2} = \sum_{0}^{n} \frac{n!}{(2n+1)!!}$  

$R(n+1) = R(n) * \frac{n}{2n+1}, R(1) = 1$  

$sum = π = 2 * \sum_{a=1}^{\infty}R(n)$

</span>   
</center>  

从公式中可以看出，我们只需要将每一个`R(n)`的值计算出，随后将结果加和乘二即可得到`π`的近似值。然而，如果使用这种办法去满足500位的精确度，我们就不能只计算前500位，而是要计算到600位以上。  

在实际算法计算中，我们构造两个双链表分别用于计算每一位的`R(n)`和存储最终的近似数，记这两个链表为num与sum。  

num表中首元节点记录了每一轮`R(n)`的个位，后续节点分别存储十分位、百分位、千分位……  
sum表与num表各节点存储意义完全相同，但sum表存储的总体是最后满足精度需求的`π`的近似值。

利用指针循环移动先算分子作乘法，再算分母作除法，最后将结果存入结果链表，根据输入的`n`值来输出指定位数的`π`近似值。  

> 基本的算法思路如下：  
> + 定义两个双链表分别用于计算各`R(n)`的值和存储最后的`π`近似值，将链表中的各值置为0。  
> + 在计算链表中，从尾部开始向表头计算分子作乘法，如果遇到进位，就将`ret`记录保存到下一节点在作乘法时加上。  
> + 计算完乘法后，再从表头向表尾遍历节点作除法，如果遇到借位，就将`ret`记录保存到下一节点在作除法时加上`ret*10`，这样在每轮乘除结束之后，能够保证各节点所存储的`R(n)`每一位在进位和借位上的正确性。  
> + 计算完乘法和除法后，将num当前的每一节点的数据域的值对应地加到sum表各节点中，并在计算时从高位到地位考虑进位，若存在进位，就将`ret`记录下来保存到下一节点加上。  
> + 在完成指定轮数的迭代（代码中设置了10000轮，即计算到`R(10000)`），以保整近似数的精确度要求。  
> + 最后根据读入的`n`值来输出指定位数的`π`的近似值。  

> 这里为了方便理解算法思路，将前两轮的迭代结果展示如下：